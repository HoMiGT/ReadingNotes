围绕业务能力构建，康威定律，有怎样结构、规模、能力的团队，就会产生对应结构、规模、能力的产品。这个结论是必然的演化结果。

产品化思维。避免把软件研发视作要去完成某种功能，而是视作一种持续改进、提升的过程。

技术架构者的第一职责就是决策权衡，有利有弊才需要决策，有取有舍才需要权衡，如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，恐怕将无可避免地陷入选择困难症的境遇之中。

我们谈历史，重点不在考古，而是借历史之名，理解每种架构出现的意义与淘汰的原因，为的是更好地解决今天的现实问题，寻找出未来架构演进的发展道路。

软件开发的最大挑战就在于只能在不完备的信息下决定当前要处理的问题。

进程间通信：
- 管道Pipe或具名管道(Named Pipe)
- 信号(Signal)
- 信号量(Semaphore)
- 消息队列(Message Queue)
- 共享内存(Shared Memory)
- 本地套接字接口(IPC Socket)


**实际权威来自信息优势，这一逻辑也适用于单位内部**

**成功的政策背后是成功的协商和妥协，而不是机械的命令与执行，所以理解利益冲突，理解协调和解决机制，是理解政策的基础**

**铜头、铁嘴、顺风耳、橡皮腰、茶壶肚、兔子腿**

网络稳定与宕机恢复能力与CAP不可兼得原理在分布式中齐名。

透明多级分流系统     
- 客户端缓存
```
在HTTP协议设计之初，便确定了服务端与客户端之间"无状态(Stateless)"的交互原则
好处是简化HTTP服务器的设计，为其水平扩展留下广袤的控件
坏处是不可避免的携带重复的数据，导致网络性能降低

1. 状态缓存： 对目标网络的状态判断，一种是301永久重定向，另一种增加了HSTS机制，用于避免依赖301/302跳转HTTPS时可能产生的降级中间人劫持。

原理：在服务端对客户端请求的响应中附带一些条件，要求客户端在遇到相同的请求时，先判断一下条件是否满足，如果满足，就直接用上一次服务器给予的响应来代替，不必重新访问。
2. 强制缓存：
根据约定，强制缓存在浏览器的地址输入、页面链接跳转、新开窗口、前进和后退中均可生效，但在用户主动刷新页面时应当失效。
HTTP协议中设有以下俩个Header实现强制缓存

Expires
是HTTP/1.0协议中开始提供的Header, 后面跟随一个截止时间参数
`
HTTP/1.1 200 OK
Expires: Web, 8 Apr 2025 10:00:00 GMT
`
有明显的几个问题，
一是受客户端本地时间影响。譬如，收到响应后，客户端修改了本地时间，将时间前后调整几分钟，就可能会造成缓存提前失效或超期持有。
二是无法处理设计用户身份的私有资源。譬如，某些资源被登录用户缓存在自己的浏览器上是合理的，但如果被代理服务器或内容分发网络缓存起来，则可能被其他未认证的用户所获取。
三是无法描述不缓存的语义。譬如，浏览器为了提高性能，往往会自动在当次会话中缓存某些MIME类型的资源，在HTTP/1.0的服务器中就缺乏强制不允许浏览器缓存某个资源。

`
HTTP/1.1 200 OK
Cache-Control: max-age=600
`
是HTTP/1.1协议中定义的强制缓存Header, 它的语义比Expires丰富了很多，同时存在优先级Cache-Control更高。
Cache-Control的标准参数
* max-age  与  s-maxage  s是share的缩写，意味着共享缓存的有效时间
* public 和 private  指明是否涉及用户身份的私有资源，如果是public，则可以被代理、CDN等缓存; 如果是private, 则只能由用户的客户端进行私有缓存
* no-cache 和 no-store  no-cache表明该资源不应该被缓存，哪怕是同一个会话中对同一URL地址的请求，也必须从服务端获取，令强制缓存完全失效，但此时下一节中的协商缓存机制依然是生效的；
no-store不强制会话中相同URL资源的重复获取，但禁止浏览器、CDN等以任何形式保护该资源。
* no-transform: 禁止以任何形式修改资源。 譬如，某些CDN、透明代理支持GZip压缩图片或文本，以提升网络性能，而no-transform禁止了这样的行为，它不允许Content-Encoding、Content-Range、Content-Type进行任何形式的修改。
* min-fresh 和 only-if-cached： 这俩个参数是仅用于客户端的请求Header。 min-fresh后面跟随一个以秒为单位的数字，用于建议服务器能返回一个不少于该时间的缓存资源。only-if-cached表示客户端要求不给它发送资源的具体内容，
此时客户端仅能使用事先缓存的资源来进行响应，若不能缓存命中，就直接返回503/Service Unavailable错误。
* must-revalidate 和 proxy-revalidate: must-revalidate表示在资源过期后，一定要从服务器中进行获取，即超过了max-age的时间后，就等同于no-cache的行为, proxy-revalidate用于提示代理、CDN等设备资源过期后的缓存行为。

3. 协商缓存：
* Last-Modified和If-Modified-Since是服务端的响应Header，用于告诉客户端这个资源的最后修改时间。对于带有这个Header的资源，当客户端需要再次请求时，会通过If-Modified-Since把之前收到的资源最后修改时间发送回服务端。
如果此时服务端发现资源在该时间后没有被修改过，就返回304/Not Modified的响应，无须附带消息体，即可达到节省流量的目的
`
HTTP/1.1 304 Not Modified
Cache-Control: public, max-age=600
Last-Modified: Web, 8 Apr 2025 11:34:00 GMT
`
如果此时服务端发现资源在该时间之后有变动，就会返回200/OK的完整响应，在消息体中包含最新的资源
`
HTTP/1.1 200 OK
Cache-Control: public, max-age=600
Last-Modified: Web, 8 Apr 2025 11:37:00 GMT
Content
`
ETag和If-None-Match：ETag是服务端的响应Header, 用于告诉客户端这个资源的唯一标识。是一致性最强且性能最差的缓存机制，服务器对每次请求资源进行hash计算。
无资源变化
`
HTTP/1.1 304 Not Modified
Cache-Control: public, max-age=600
ETag: "28c3f612-ceb0-4ddc-ae35-79ca840c5fa"
`
有资源变化
`
HTTP/1.1 200 OK
Cache-Control: public, max-age=600
ETag: "28c3f612-ceb0-4ddc-ae35-79ca840c5fa"
Content
`
根据约定，协商缓存在浏览器地址输入、页面链接跳转、新开窗口、前进、后退中生效，而在用户主动刷新页面(F5)时同样是生效的，只有用户前置刷新(Ctrl+F5)或明确禁用缓存时才会生效(客户端发送 'Cache-Control:no-cache')。

```
- 域名解析
- 传输链路
- 内容分发
- 负载均衡
- 服务端缓存
